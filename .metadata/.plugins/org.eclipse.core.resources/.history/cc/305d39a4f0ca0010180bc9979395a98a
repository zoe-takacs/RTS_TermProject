/*
 * interrupt_handlers.c
 *
 *  Created on: Nov 26, 2025
 *      Author: Zoe
 */

#include <stdint.h>
#include <main.h>
#include "FreeRTOS.h"

extern TIM_HandleTypeDef htim2;
extern osThreadId_t vert_motor_controller_task;
extern osThreadId_t rot_motor_controller_task;

void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
{
    if (htim->Instance == TIM2 && htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
    {
        __HAL_TIM_CLEAR_IT(&htim2, TIM_IT_CC1);

        if (capturing == 0)
        {
            echo_rising = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_1);

            TIM_IC_InitTypeDef sConfig = {0};
            sConfig.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
            sConfig.ICSelection = TIM_ICSELECTION_DIRECTTI;
            HAL_TIM_IC_ConfigChannel(&htim2, &sConfig, TIM_CHANNEL_1);

            capturing = 1;
        }
        else if (capturing == 1)
        {
            echo_falling = HAL_TIM_ReadCapturedValue(&htim2, TIM_CHANNEL_1);
            capturing = 2;

            // restore rising edge for next measurement
            TIM_IC_InitTypeDef sConfig = {0};
            sConfig.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
            sConfig.ICSelection = TIM_ICSELECTION_DIRECTTI;
            HAL_TIM_IC_ConfigChannel(&htim2, &sConfig, TIM_CHANNEL_1);
        }
    }
}

void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
    if (GPIO_Pin == mode_btn_Pin)
    {
//        change_mode();
    	pass;
    }
    else if (GPIO_Pin == vert_btn_Pin)
    {
    	vTaskResume(vert_motor_controller_task);
    }
    else if (GPIO_Pin == rot_btn_Pin)
	{
    	vTaskResume(rot_motor_controller_task);
	}
    else if (GPIO_Pin == auto_btn_Pin)
	{
		pass;
	}
}
