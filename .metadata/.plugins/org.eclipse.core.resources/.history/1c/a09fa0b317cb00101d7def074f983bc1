#include "crane.h"
#include "FreeRTOS.h"
#include "task.h"
#include <stdio.h>
#include "queue.h"

extern TaskHandle_t vert_motor_controller_handle;
extern TaskHandle_t  rot_motor_controller_handle;

extern QueueHandle_t usartQueue;

void vert_motor_controller_task(void *argument)
{
	// === 1) Initialize the vertical servo ===
    uint16_t pwm = 1500;
    VertServo_Init();
    HCSR04_Init();
    char msg[] = "Vertical Motor Controller Task Initialized!\r\n";
    xQueueSend(usartQueue, &msg, 0);
    vTaskSuspend(vert_motor_controller_handle);

    for (;;)
    {
    	// === 2) Check if vertical button is still pressed ===
        if (!Read_Vert_Button())
        {
        	// === If not pressed, then suspend task ===
        	char msg_suspend[] = "Vertical Motor Controller Task suspended!\r\n";
        	xQueueSend(usartQueue, &msg_suspend, 0);
            vTaskSuspend(NULL);
            char msg_unsuspend[] = "Vertical Motor Controller Task UNsuspended!\r\n";
            xQueueSend(usartQueue, &msg_unsuspend, 0);
            continue;
        }

        // === 3) If button is pressed, then check the direction to go and current height ===
        uint8_t dir = Read_Vert_Switch();
        float dist = HCSR04_ReadDistanceCm();

        // === 4) If distance measurement failed, or displacement is maxed out skip===
        if ((dist == -1) || (dist >= VERT_DIST_MAX_CM && dir == DIR_UP) ||
            (dist <= VERT_DIST_MIN_CM && dir == DIR_DOWN))
        {
            vTaskDelay(pdMS_TO_TICKS(20));
            continue;
        }

        // === 5) Check direction, and adjust pwm accordingly ===
        if (dir == DIR_UP){
//            pwm += VERT_PWM_STEP_US;
        }
        else {
//            pwm -= VERT_PWM_STEP_US;
        }

        char msg_pwm[25];
        snprintf(msg_pwm, sizeof(msg_pwm), "Vertical PWM: %u\r\n", pwm);
        xQueueSend(usartQueue, &msg_pwm, 0);

        VertServo_SetPulseUs(pwm);

        // === 6) Wait before sampling again ===
        vTaskDelay(pdMS_TO_TICKS(20));
    }
}

void rot_motor_controller_task(void *argument)
{
	// === 1) Initialize the rotating servo ===
    uint16_t pwm = 1500;
    RotServo_Init();
    char msg[] = "Rotational Motor Controller Task initialized!\r\n";
    xQueueSend(usartQueue, &msg, 0);
    vTaskSuspend(rot_motor_controller_handle);

    for (;;)
    {
    	// === 2) Check if rotational button is still pressed ===
        if (!Read_Rot_Button())
        {
        	char msg_suspend[] = "Rotational Motor Controller Task suspended!\r\n";
        	xQueueSend(usartQueue, &msg_suspend, 0);
        	VertServo_SetPulseUs(1500);
        	vTaskSuspend(NULL);
            char msg_unsuspend[] = "Rotational Motor Controller Task UNsuspended!\r\n";
            xQueueSend(usartQueue, &msg_unsuspend, 0);
            continue;
        }

        // === 3) If button is pressed, then check the direction to go ===
        uint8_t dir = Read_Rot_Switch();

        // === 4) Check direction, and adjust pwm accordingly ===
        if (dir == DIR_RIGHT){
        	pwm = 1400;
        	VertServo_SetPulseUs(1400);
//            pwm += ROT_PWM_STEP_US;
        }
        else{
        	pwm = 1600;
        	VertServo_SetPulseUs(1600);
//            pwm -= ROT_PWM_STEP_US;
        }

        char msg_pwm[25];
		snprintf(msg_pwm, sizeof(msg_pwm), "Rotational PWM: %u\r\n", pwm);
		xQueueSend(usartQueue, &msg_pwm, 0);
        RotServo_SetPulseUs(pwm);

        // === 5) Wait before sampling again ===
        vTaskDelay(pdMS_TO_TICKS(20));
    }
}
